# Moduo

---

# Muduo 网络库

## 学习目的

> - **理解：阻塞 / 非阻塞、同步 / 异步**
> - **理解：Linux 上的五种 IO 模型【 ... 】**
> - **掌握 epoll 的原理和优势**
> - 认识并理解 Reactor 模型
> - 学习开源项目核心代码的设计思路
> - **掌握基于事件驱动和事件回调的 epoll + 线程池面向对象编程**
> - 深刻理解 muduo 网络库源码，以及使用 C++11 重构



----



## 知识储备

> - 传输层协议：TCP 协议 和 UDP 协议
> - 理解并掌握 TCP / UDP 编程步骤
> - 熟悉 Linux 上的 IO 多路复用
> - Linux 多线程编程



----



## 阻塞 / 非阻塞、同步 / 异步

### 基本认识

> 这四个关键词实际就是 IO 事件中与数据打交道时的不同处理方式。
>
> ---
>
> 一次 IO 操作可以分成两个阶段
>
> - **数据准备阶段**【根据系统IO操作的就绪状态】：阻塞 / 非阻塞
>   - 阻塞的表现：recv 函数不返回！所处线程执行阻塞 “停止” 在 recv 函数处！
>     - 此时，读到数据的返回值是：所读取到的数据量大小！
>     - 阻塞的唤醒时机，有数据！
>   - 非阻塞的表现：recv 函数会返回！所处线程正常执行！
>     - 如果 size = -1，有两层意义：
>       - 可能是非阻塞返回表现【errno = EAGAIN 或 errno = EWORLDBLOCK】
>       - 可能是系统内部错误
>     - size = 0 表示：网络对端关闭了连接！
> - **数据读写阶段**【根据应用程序和内核的交互方式】：同步 / 异步
>   - 同步：数据从 TCP 接收缓冲区拷贝到 用户层的 buf 中，该过程的是耗时的，耗时在应用程序，而不是内核！
>     - 注意：recv 函数是同步接口！
>   - 异步：就是数据的拷贝托管给操作系统，而用户层应用程序可以随心所以，如果操作系统完成了拷贝，就会 `通知` 应用程序，通知方式：信号 / 回调函数！
>
> ---
>
> 注意：并发时也有同步异步概念！
>
> **在处理 IO 的时候，阻塞和非阻塞都是同步 IO。只有使用了特殊的 API 才是异步IO。**

~~~c++
// IO 接口
ssize_t recv(int sockfd, void* buf, size_t len, int flags);
=> sockfd：数据源（文件描述符），是否阻塞就是看此处的文件描述符读取限制（阻塞/非阻塞）
=> buf：用户（应用程序）层的数据缓存
=> len：buf 的大小
=> 一般填：0

// 对于 TCP 
// 内核层有 TCP 接收缓冲区（就是我们读取的数据源）
1. 调用 recv 时，就是如果 TCP 接收缓冲区有数据，就开始把其中的数据 往用户层的 buf 里面搬【该过程中如果没有搬完，就不能直接向下执行，这个和是否阻塞无关，在计算机的角度，这个搬运速度是相当快的！时间消耗在应用程序层】
2. recv 函数返回后，就是说明搬运完成，buf 中有数据了！
~~~



![](.\pic\QQ截图20240206170551.png)





### 理解性总结

> 阻塞与非阻塞：
>
> - 关键点在于调用了 IO 操作接口后，当数据未就绪时，是否会阻塞当前线程。也就是这个时候当前线程能否继续执行其他任务！
>
> ---
>
> 同步和异步：
>
> - 同步：就是 A 向 B 提出想要进行某种操作，B 直接提供必要的资源，其他操作 A 自行完成！A 无法做 其他事！
>   - 操作是 提出者 自己完成！
> - 异步：就是 A 把想做的操作和操作完成后的反馈（或者说通知 A 操作完成的方式）告诉 B，也就是甩手掌柜式的将任务托付给 B，A 只要知道是否完成，同时 A 可以做其他事！
>   - 操作托管给其他人！





### 总结说明

> 阻塞：指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。
>
> 非阻塞：指在不能立刻得到结果之前，该调用不会阻塞当前线程。线程无需等待，该返回带有特定的错误码（EAGAIN / EWORLDBLOCK）
>
> - 非阻塞 IO 操作需要程序员主动设置反复尝试读取文件描述符，以尝试读取数据！该操作叫做：【轮询】！
> - 对于 CPU 来说，这是性能上的较大消耗，一般只有特定情形才用！
>
> 阻塞与非阻塞关注的是：程序在 【`进行 IO 操作时`】 是否会被阻塞，即是否等待 IO 操作完成 / 程序在处理 I/O 操作时是否需要等待。
>
> 是否阻塞的根本因素在于：被读取的文件描述符属性！（阻塞 / 非阻塞）
>
> ---
>
> 同步 IO：同步 I/O 操作是一种阻塞式的操作方式。在同步 I/O 中，程序在发起一个 I/O 操作后会一直等待该操作完成，然后才能继续执行后续的代码。这意味着程序会在进行 I/O 操作期间被阻塞，无法执行其他任务，直到 I/O 操作完成。
>
> 异步 IO：异步 I/O 操作是一种非阻塞式的操作方式。在异步 I/O 中，程序发起一个 I/O 操作后，不需要等待该操作完成，而是可以继续执行后续的代码。程序会注册一个回调函数（Callback），该函数将在 I/O 操作完成时被调用，通知程序数据已经就绪。
>
> - 使用异步 I/O 的操作方式，程序可以在等待 I/O 操作完成的同时继续执行其他任务，从而**提高了程序的并发性和性能。**
> - 异步操作通常需要一些额外的编程机制来处理回调函数的调用和数据就绪的通知。
>
> 同步与异步关注的是：程序在 【`发起IO操作后`】 是否需要等待IO操作完成，即是否等待IO操作的结果。



### 面试时的回答方式

> 阻塞 / 非阻塞、同步 / 异步 是用来描述 IO 操作的状态的！
>
> 一个典型的 IO 操作，应该包含：数据准备 和 数据读写！



---



## Linux 五种 IO 模型

> 五种模型：
>
> - 阻塞 IO、非阻塞 IO、信号驱动 IO 、IO 多路复用、异步 IO



### 阻塞 IO【Blocking】

> **阻塞IO：在内核将数据准备好之前，系统调用会一直等待。**
>
> - 所有的套接字（ bind、accept、recv、send、listen、recvfrom、... ），默认都是阻塞方式。

![](.\pic\QQ截图20240206192635.png)



### 非阻塞 IO【Non-Blocking】

> **非阻塞 IO：如果内核还未将数据准备好，系统调用仍然会直接返回，并且返回 EWOULDBLOCK 错误码！**
>
> - **非阻塞 IO 往往需要程序员循环的方式反复尝试读写文件描述符，这个过程称为【轮询】**。**这对CPU来说是较大的浪费, 一般只有特定场景下才使用。**
>
> ---
>
> 设置方式：

~~~c++
setblockopt(sockfd);
~~~





![](.\pic\QQ截图20240206192646.png)



### 信号驱动 IO【Signal-Driven】

> **信号驱动 IO：内核将数据准备好的时候，使用 SIGIO 信号通知应用程序进行IO操作。**
>
> ---
>
> 逻辑（使用信号驱动 IO）：
>
> - 应用的进程注册好信号处理程序
> - 该程序会递交给内核，该程序就是包含了资源“请求”信息。告知操作系统去准备或检查资源，准备好了就通知进程，这个时间段内进程可以继续执行！
> - 进程收到信号后，就说明了数据资源就绪！
> - 进程可以去读取数据了，但是依旧会调用一个默认为阻塞的接口去读取数据。
>
> ---
>
> **内核在第一个阶段是异步，在第二个阶段是同步**；
>
> **与非阻塞IO的区别在于它提供了消息通知机制**，不需要用户进程不断的轮询检查，减少了系统API的调用次数，提高了效率。

![](.\pic\QQ截图20240206192708.png)



### IO 多路复用【IO Multiplexing】

> **IO 多路转接：虽然从流程图上看起来和阻塞 IO 类似。实际上最核心在于 IO 多路转接能够同时等待多个文件描述符的就绪状态。**
>
> - select 等函数含有多个文件描述符！该函数相当于在等和拷贝中只负责等！recvfrom 只负责拷贝数据（此时无需等待，读取时一定是有数据的！）
> - 有设置是否阻塞以及轮询周期的参数！

![](.\pic\QQ截图20240206192657.png)



### 异步 IO 【Asynchronous】

> **异步 IO：由内核在数据拷贝完成时，通知应用程序（而信号驱动是告诉应用程序何时可以开始拷贝数据）**

![](.\pic\QQ截图20240206192726.png)



~~~c++
// 异步 IO 使用到的结构体
struct aiocb {
	int aio_fildes,
	off_t aio_offset,
	volatile void *aio_buf,
	size_t aio_nbytes,
	int aio_reqprio,
	struct sigevent aio_sigevent,
	int aio_lio_opcode
};
~~~





---



## 良好的网络服务器设计思路

### 设计思路来源

> 在这个多核处理器的时代，服务端网络编程如何选择线程模型呢？ 
>
> - 关于多核的优势：可以同时执行多个指令或任务。 每个核心都可以独立地执行指令和处理任务。 多核处理器可以将负载分配到不同的核心上，从而实现并行处理。
>
> ---
>
> libev 作者的观点：one loop per thread is usually a good model. 【每个线程一个循环，通常是一个很好的模型。】
>
> 基于这一点，我们可以比较容易的反应到：对于一个多线程服务端的设计，就可以转换成设计多个事件循环（event loop），只要让每个线程去处理一个事件循环，同时如果事件循环具备高效且易于使用，不就是一个比较良好的服务端吗！



### 关于数据与事件循环的杂谈

> 就我个人浅薄的认识而言，我们处于计算机时代，网络时代，我们与世界的沟通方式无非就是数据！
>
> 我们通过图片看到的世界，就是计算机或其他设备完成了特定格式数据的格式化，我们才看见了多姿多彩的世界！
>
> 我们和世界的交流就是通过数据！
>
> 我不否认存在其他方法的交流，比如面对面交流等！
>
> ---
>
> 那么这里要谈论的 `事件循环` 和数据之间有什么关系？
>
> 我的解释是：事件循环 “操作” 的对象就是数据（每个人想法或认识不同，这是我的观点！）



### 事件循环的讨论

> 先来**结论**：
>
> - **事件循环（event loop）是 non-blocking 网络编程的核心！**
>
> 再来说 “常规设计思路”：
>
> - **非阻塞 IO 和 IO 多路复用 几乎总是一起使用！**
>
> ---
>
> **讨论：**
>
> **为什么用非阻塞 IO、而不是 阻塞 IO？**
>
> - 显然，它们的最大区别在于：**执行 IO 操作并的到结果前，两者所处线程的运行状态！**
> - 阻塞 IO，会挂起线程，而无法继续执行后续任务！对于一个服务器而言，阻塞式的操作是致命的。
> - 非阻塞 IO，可以不用一直等待系统调用反馈结果，系统操盘就绪数据时，可以同时执行其他任务！
>
> **非阻塞 IO 的缺点是什么？**（对于性能要求高的场景）
>
> - **缺点在于：需要主动【`轮询`】检查数据就绪状态 / IO 操作完成情况！浪费 CPU 资源！**
> - 对于高性能服务器而言，无疑是不可取的！
>
> **IO 多路复用的优点是什么？**
>
> - **优点：能够同时监测多个文件描述符的状态变化。**
> - **同时，IO 多路复用的系统调用是支持阻塞和非阻塞的！**
> - **它有通知机制！该机制可以弥补非阻塞 IO 中的主动轮询操作！**





## Reactor 模型（事件驱动模型）

### 模型认识

> The reactor design pattern is an event handling pattern for handling service requests delivered concurrently to a service handler by one or more inputs. The service handler then demultiplexes the incoming requests and dispatches them synchronously to the associated request handlers.
>
> 反应器设计模式是一种事件处理模式，用于处理通过一个或多个输入并发地传递给服务处理程序的服务请求。然后，服务处理程序将传入的请求解复用，并将它们同步地分派给相关的请求处理程序。



### 模型组件

> - Event 事件
> - Reactor 反应堆
> - Demultiplex 事件分发器【 基于 IO 多路复用 】
> - Evanthandler 事件处理器
>
> ---



### 模型组件交互认识

> **Event 事件 => Reactor 反应堆：**（从事件到反应堆）
>
> - 首先，我们会注册事件和给定事件的处理（或者说是回调）方法！
>   - 该事件是我们要关注的东西，比如：TCP 接收缓冲区是否有数据【Eevnt】？
>   - 如果有？则进行读取【Handler】！
>
> ---
>
> **Reactor 反应堆**
>
> - 实际就是：事件和对应事件的处理方法的集合！
> - 如果要自己定义该集合的管理方式，会用什么数据结构？
>   - 一般用 map 表存储即可，键值映射。
> - 工作：Reactor 反应堆中的事件需要被监控 / 管理，对应的需要事件状态。
>   - epoll add：将待监控事件加入到 epoll 监控模型中。
>   - epoll mod：修改 epoll 监控模型中的事件
>   - epoll del：在 epoll 监控模型中删除某个事件
>
> ---
>
> **Reactor 反应堆 => Demultiplex 事件分发器**【一般就是用 epoll 】
>
> - **启动反应堆 => 开启事件循环 epoll_wait 监视事件的状态变化！**
> - 如果是服务器！
>   - 启动之后，就开始检测：新用户的连接请求事件，已连接用户的读写请求事件等。
> - 如果检测到事件变化，即某种事件就绪！就会给 Reactor 反应堆 进行事件返回！
>   - 为什么返回？事件分发器只是监测了事件就绪的准备情况，并不参与事件就绪的方法调用！
>
> ---
>
> **Reactor 反应堆 => Evanthandler 事件处理器：**
>
> - 就绪的事件，去调用相应的回调方法处理事件！
> - 如果是服务器：可能涉及数据的序列化与反序列化【 json、protobuf 等 】，数据包装/编码发送等等操作对客户端用户操作进行响应。



![](.\pic\QQ截图20240206211516.png)





### Muduo Reactor 模型

> 

![](.\pic\QQ截图20240206214022.png)